# 🗄️ 데이터베이스 스키마 설계 가이드

> PM이 알아야 할 데이터베이스 설계 원칙과 실전 가이드

---

## 🎯 학습 목표

- ✅ 데이터베이스 스키마 설계 기초
- ✅ 테이블 관계 (1:1, 1:N, N:M) 이해
- ✅ JPA Entity로 변환하는 방법
- ✅ AI에게 스키마 구현을 지시하는 방법

---

## 📚 데이터베이스 설계 기초

### 엔티티 (Entity)란?

- 데이터베이스에 저장할 **대상/객체**
- 예: 사용자(User), 게시글(Post), 댓글(Comment)
- 테이블로 구현됨

### 속성 (Attribute)

- 엔티티가 가지는 **특성/정보**
- 예: 사용자의 이름, 이메일, 비밀번호
- 테이블의 컬럼(Column)으로 구현됨

### 관계 (Relationship)

- 엔티티 간의 **연관성**
- 1:1, 1:N, N:M 관계

---

## 🔗 테이블 관계 이해하기

### 1:1 관계 (One-to-One)

**예시**: 사용자 ↔ 프로필

```
User              Profile
─────────────    ─────────────
id (PK)          id (PK)
email            user_id (FK) ← UNIQUE
name             bio
                 avatar
```

- 한 사용자는 하나의 프로필만 가짐
- 한 프로필은 한 사용자에게만 속함

### 1:N 관계 (One-to-Many)

**예시**: 사용자 ↔ 게시글

```
User              Post
─────────────    ─────────────
id (PK)          id (PK)
email            user_id (FK) ← 여러 개 가능
name             title
                 content
```

- 한 사용자는 여러 게시글을 작성 가능 (1:N)
- 한 게시글은 한 사용자에게만 속함 (N:1)

### N:M 관계 (Many-to-Many)

**예시**: 게시글 ↔ 태그

```
Post              Post_Tag         Tag
─────────────    ─────────────    ─────────────
id (PK)          post_id (FK)     id (PK)
title            tag_id (FK)      name
content          (복합 PK)
```

- 한 게시글은 여러 태그를 가질 수 있음
- 한 태그는 여러 게시글에 속할 수 있음
- **중간 테이블** (Post_Tag) 필요

---

## 📋 테이블 설계 템플릿

### 기본 템플릿

```markdown
## 테이블명: [테이블명]

**설명**: [이 테이블이 저장하는 데이터]

### 컬럼

| 컬럼명 | 타입 | NULL | 기본값 | 설명 | 제약조건 |
|--------|------|------|--------|------|----------|
| id | BIGINT | NO | AUTO | 기본키 | PRIMARY KEY |
| name | VARCHAR(100) | NO | - | 이름 | - |
| created_at | DATETIME | NO | CURRENT_TIMESTAMP | 생성일시 | - |

### 인덱스

| 인덱스명 | 컬럼 | 타입 | 설명 |
|---------|------|------|------|
| idx_name | name | INDEX | 이름 검색 최적화 |
| uk_email | email | UNIQUE | 이메일 중복 방지 |

### 관계

- User (N) → Post (1): user_id
- Post (1) → Comment (N): post_id
```

---

## 💼 실전 예시: 블로그 데이터베이스

### ERD (Entity Relationship Diagram)

```
┌─────────────┐
│    User     │
├─────────────┤
│ id (PK)     │
│ email       │──────┐
│ password    │      │
│ name        │      │
│ role        │      │
│ created_at  │      │
│ updated_at  │      │
└─────────────┘      │
       │             │ 1:N
       │ 1:N         │
       ▼             ▼
┌─────────────┐   ┌─────────────┐
│    Post     │   │   Comment   │
├─────────────┤   ├─────────────┤
│ id (PK)     │   │ id (PK)     │
│ user_id (FK)│───┤ post_id (FK)│
│ title       │ 1:N│ user_id (FK)│
│ content     │◄───┤ content     │
│ status      │   │ parent_id   │← Self-referencing
│ view_count  │   │ created_at  │
│ created_at  │   └─────────────┘
│ updated_at  │
│ deleted_at  │
└─────────────┘
       │
       │ N:M
       ▼
┌─────────────┐   ┌─────────────┐
│  Post_Tag   │   │    Tag      │
├─────────────┤   ├─────────────┤
│ post_id (FK)│───│ id (PK)     │
│ tag_id (FK) │   │ name        │
└─────────────┘   └─────────────┘
```

---

### 테이블 상세 설계

#### 1. User 테이블

```sql
CREATE TABLE user (
    id BIGINT NOT NULL AUTO_INCREMENT COMMENT '사용자 ID',
    email VARCHAR(255) NOT NULL COMMENT '이메일 (로그인 ID)',
    password VARCHAR(255) NOT NULL COMMENT '비밀번호 (BCrypt 암호화)',
    name VARCHAR(50) NOT NULL COMMENT '이름',
    role VARCHAR(20) NOT NULL DEFAULT 'USER' COMMENT '역할 (USER, ADMIN)',
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '생성일시',
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '수정일시',
    
    PRIMARY KEY (id),
    UNIQUE KEY uk_email (email),
    INDEX idx_role (role),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='사용자';
```

**컬럼 설명**:
- `id`: 자동 증가하는 기본키
- `email`: 로그인 ID로 사용, 중복 불가 (UNIQUE)
- `password`: BCrypt로 암호화하여 저장 (60자)
- `role`: 권한 관리용 (USER, ADMIN 등)
- `created_at`, `updated_at`: 자동 타임스탬프

---

#### 2. Post 테이블

```sql
CREATE TABLE post (
    id BIGINT NOT NULL AUTO_INCREMENT COMMENT '게시글 ID',
    user_id BIGINT NOT NULL COMMENT '작성자 ID',
    title VARCHAR(200) NOT NULL COMMENT '제목',
    content TEXT NOT NULL COMMENT '내용',
    status VARCHAR(20) NOT NULL DEFAULT 'PUBLISHED' COMMENT '상태 (DRAFT, PUBLISHED)',
    view_count INT NOT NULL DEFAULT 0 COMMENT '조회수',
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '생성일시',
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '수정일시',
    deleted_at DATETIME NULL COMMENT '삭제일시 (Soft Delete)',
    
    PRIMARY KEY (id),
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    INDEX idx_user_id (user_id),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at),
    INDEX idx_deleted_at (deleted_at),
    FULLTEXT INDEX ft_title_content (title, content) COMMENT '전문 검색 인덱스'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='게시글';
```

**특징**:
- `deleted_at`: Soft Delete (삭제 시 NULL이 아닌 삭제 시간 기록)
- `FULLTEXT INDEX`: 한글 검색을 위한 전문 검색 인덱스
- `ON DELETE CASCADE`: 사용자 삭제 시 게시글도 함께 삭제

---

#### 3. Comment 테이블

```sql
CREATE TABLE comment (
    id BIGINT NOT NULL AUTO_INCREMENT COMMENT '댓글 ID',
    post_id BIGINT NOT NULL COMMENT '게시글 ID',
    user_id BIGINT NOT NULL COMMENT '작성자 ID',
    parent_id BIGINT NULL COMMENT '부모 댓글 ID (대댓글)',
    content VARCHAR(500) NOT NULL COMMENT '내용',
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '생성일시',
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '수정일시',
    deleted_at DATETIME NULL COMMENT '삭제일시',
    
    PRIMARY KEY (id),
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (parent_id) REFERENCES comment(id) ON DELETE CASCADE,
    INDEX idx_post_id (post_id),
    INDEX idx_user_id (user_id),
    INDEX idx_parent_id (parent_id),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='댓글';
```

**특징**:
- `parent_id`: Self-referencing (대댓글 구현)
- `parent_id`가 NULL이면 원댓글, 값이 있으면 대댓글

---

#### 4. Tag 테이블

```sql
CREATE TABLE tag (
    id BIGINT NOT NULL AUTO_INCREMENT COMMENT '태그 ID',
    name VARCHAR(50) NOT NULL COMMENT '태그명',
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '생성일시',
    
    PRIMARY KEY (id),
    UNIQUE KEY uk_name (name)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='태그';
```

---

#### 5. Post_Tag 테이블 (중간 테이블)

```sql
CREATE TABLE post_tag (
    post_id BIGINT NOT NULL COMMENT '게시글 ID',
    tag_id BIGINT NOT NULL COMMENT '태그 ID',
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '생성일시',
    
    PRIMARY KEY (post_id, tag_id),
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (tag_id) REFERENCES tag(id) ON DELETE CASCADE,
    INDEX idx_post_id (post_id),
    INDEX idx_tag_id (tag_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='게시글-태그 관계';
```

**특징**:
- 복합 기본키 (post_id, tag_id)
- N:M 관계 구현

---

## 🔄 JPA Entity로 변환하기

### User Entity

```java
@Entity
@Table(name = "user")
@Getter @Setter
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true, length = 255)
    private String email;
    
    @Column(nullable = false, length = 255)
    private String password;
    
    @Column(nullable = false, length = 50)
    private String name;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private UserRole role = UserRole.USER;  // USER, ADMIN
    
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Post> posts = new ArrayList<>();
    
    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @LastModifiedDate
    @Column(nullable = false)
    private LocalDateTime updatedAt;
}
```

---

### Post Entity

```java
@Entity
@Table(name = "post")
@Getter @Setter
@SQLDelete(sql = "UPDATE post SET deleted_at = NOW() WHERE id = ?")
@Where(clause = "deleted_at IS NULL")
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    @Column(nullable = false, length = 200)
    private String title;
    
    @Lob
    @Column(nullable = false)
    private String content;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private PostStatus status = PostStatus.PUBLISHED;  // DRAFT, PUBLISHED
    
    @Column(nullable = false)
    private Integer viewCount = 0;
    
    @ManyToMany
    @JoinTable(
        name = "post_tag",
        joinColumns = @JoinColumn(name = "post_id"),
        inverseJoinColumns = @JoinColumn(name = "tag_id")
    )
    private Set<Tag> tags = new HashSet<>();
    
    @OneToMany(mappedBy = "post", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Comment> comments = new ArrayList<>();
    
    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @LastModifiedDate
    @Column(nullable = false)
    private LocalDateTime updatedAt;
    
    private LocalDateTime deletedAt;  // Soft Delete
}
```

**주요 어노테이션**:
- `@ManyToOne`: N:1 관계 (여러 게시글 → 한 사용자)
- `@OneToMany`: 1:N 관계 (한 게시글 → 여러 댓글)
- `@ManyToMany`: N:M 관계 (게시글 ↔ 태그)
- `@SQLDelete`, `@Where`: Soft Delete 구현

---

### Comment Entity

```java
@Entity
@Table(name = "comment")
@Getter @Setter
public class Comment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "post_id", nullable = false)
    private Post post;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_id")
    private Comment parent;  // 대댓글
    
    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Comment> replies = new ArrayList<>();
    
    @Column(nullable = false, length = 500)
    private String content;
    
    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @LastModifiedDate
    @Column(nullable = false)
    private LocalDateTime updatedAt;
    
    private LocalDateTime deletedAt;
}
```

---

## 💡 설계 Best Practice

### 1. 공통 필드 추상화

```java
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
@Getter
public abstract class BaseEntity {
    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @LastModifiedDate
    @Column(nullable = false)
    private LocalDateTime updatedAt;
}

// 사용
@Entity
public class User extends BaseEntity {
    // createdAt, updatedAt 자동 상속
}
```

### 2. Soft Delete 공통화

```java
@MappedSuperclass
public abstract class SoftDeleteEntity extends BaseEntity {
    private LocalDateTime deletedAt;
    
    public void delete() {
        this.deletedAt = LocalDateTime.now();
    }
    
    public boolean isDeleted() {
        return this.deletedAt != null;
    }
}
```

### 3. 열거형 (Enum) 활용

```java
public enum UserRole {
    USER("일반 사용자"),
    ADMIN("관리자");
    
    private final String description;
    
    UserRole(String description) {
        this.description = description;
    }
}

public enum PostStatus {
    DRAFT("임시저장"),
    PUBLISHED("발행");
    
    private final String description;
    
    PostStatus(String description) {
        this.description = description;
    }
}
```

---

## 🚀 AI에게 스키마 구현 요청하기

```markdown
"다음 데이터베이스 스키마를 바탕으로 JPA Entity 클래스를 생성해줘.

[SQL 스키마 붙여넣기]

요구사항:
1. Lombok 사용 (@Getter, @Setter, @NoArgsConstructor)
2. BaseEntity 추상 클래스로 공통 필드 분리 (createdAt, updatedAt)
3. Soft Delete 지원 (deletedAt 필드)
4. 양방향 관계 설정 (편의 메서드 포함)
5. FetchType.LAZY 사용 (N+1 방지)
6. 각 어노테이션의 역할을 주석으로 설명

각 Entity의 관계와 설계 이유도 함께 설명해줘."
```

---

## 📚 다음 단계

1. **Repository 작성**: Spring Data JPA Repository 인터페이스 생성
2. **쿼리 최적화**: N+1 문제 해결, 인덱스 활용
3. **실전 프로젝트**: 실제로 Entity를 작성하고 테스트

---

**💡 핵심**: 데이터베이스 설계는 프로젝트의 근간입니다. 처음에 잘 설계하면 나중에 편합니다!

