# 📝 효과적인 프롬프트 작성법 실전 연습

> AI와의 소통을 최대화하는 프롬프트 작성 스킬 향상하기

---

## 🎯 학습 목표

이 문서를 통해:
- ✅ 모호한 요청을 구체적인 프롬프트로 변환하는 능력
- ✅ 상황별로 적절한 프롬프트를 작성하는 감각
- ✅ AI가 최고의 결과를 낼 수 있는 지시 방법

---

## 📊 프롬프트 품질 레벨

### Level 1: 초보자 ⭐
```
"로그인 기능 만들어줘"
```
- ❌ 너무 모호함
- ❌ 기술 스택 불명확
- ❌ 요구사항 없음

### Level 2: 중급자 ⭐⭐⭐
```
"Spring Boot로 JWT 로그인 API를 만들어줘.
POST /api/auth/login 엔드포인트로 이메일과 비밀번호를 받아서
JWT 토큰을 반환하도록."
```
- ✅ 기술 스택 명시
- ✅ 엔드포인트 명확
- ⚠️ 세부 요구사항 부족
- ⚠️ 에러 처리 미명시

### Level 3: 고급자 ⭐⭐⭐⭐⭐
```
"Spring Boot 3.2 + Spring Security를 사용한 JWT 인증 API를 구현해줘.

[환경]
- Java 17
- Spring Boot 3.2
- MySQL 8.0
- JWT 라이브러리: jjwt 0.12.x

[API 명세]
엔드포인트: POST /api/auth/login
요청 바디:
{
  "email": "user@example.com",
  "password": "password123"
}

성공 응답 (200):
{
  "token": "eyJhbGc...",
  "expiresIn": 86400,
  "user": {
    "id": 1,
    "email": "user@example.com",
    "name": "홍길동"
  }
}

실패 응답 (401):
{
  "error": "INVALID_CREDENTIALS",
  "message": "이메일 또는 비밀번호가 올바르지 않습니다."
}

[요구사항]
1. 비밀번호는 BCrypt로 암호화되어 저장
2. JWT 유효기간: 24시간
3. 이메일 형식 검증 (Validation)
4. 로그인 시도 5회 실패 시 계정 잠금 (선택사항)

[구현 방식]
- UserDetails를 구현한 Custom User 클래스 사용
- JwtTokenProvider로 토큰 생성/검증 로직 분리
- 계층형 아키텍처 (Controller → Service → Repository)

각 클래스의 역할과 주요 메서드를 주석으로 설명해주고,
보안 관련 고려사항도 함께 안내해줘."
```
- ✅ 완벽한 컨텍스트
- ✅ 명확한 API 명세
- ✅ 에러 처리 포함
- ✅ 보안 고려사항
- ✅ 아키텍처 가이드

---

## 🏋️ 실전 연습

아래의 모호한 요청을 **Level 3 프롬프트**로 변환해보세요!

### 연습 1: 게시글 목록 조회

**모호한 요청:**
```
"게시글 목록 API 만들어줘"
```

**당신의 프롬프트 작성:**
```
[여기에 작성해보세요]
















```

**모범 답안:**
<details>
<summary>클릭하여 확인</summary>

```
"Spring Boot로 게시글 목록 조회 API를 구현해줘.

[환경]
- Spring Boot 3.2, Java 17
- JPA + MySQL
- 프론트엔드: Vue 3

[API 명세]
엔드포인트: GET /api/posts
쿼리 파라미터:
- page (기본값: 0) - 페이지 번호
- size (기본값: 20) - 페이지 크기
- sort (기본값: createdAt,desc) - 정렬 기준
- search (선택) - 검색 키워드 (제목/내용)

응답 (200):
{
  "content": [
    {
      "id": 1,
      "title": "게시글 제목",
      "content": "게시글 내용 미리보기...",
      "author": {
        "id": 1,
        "name": "홍길동"
      },
      "createdAt": "2025-10-16T10:30:00",
      "viewCount": 42,
      "commentCount": 5
    }
  ],
  "pageable": {
    "currentPage": 0,
    "totalPages": 10,
    "totalElements": 195,
    "size": 20
  }
}

[요구사항]
1. Spring Data JPA의 Pageable 사용
2. N+1 문제 방지 (fetch join)
3. 검색 기능: 제목 OR 내용에 키워드 포함
4. content는 100자로 자르기
5. 삭제된 게시글 제외
6. 작성자 정보는 id, name만 포함

[추가]
- PostController, PostService, PostRepository 계층 구조
- Post와 User 엔티티 관계 설정
- 각 메서드의 역할을 주석으로 설명
- 쿼리 최적화 방법도 함께 안내"
```
</details>

---

### 연습 2: 파일 업로드

**모호한 요청:**
```
"이미지 업로드 기능 만들어줘"
```

**당신의 프롬프트 작성:**
```
[여기에 작성해보세요]
















```

**모범 답안:**
<details>
<summary>클릭하여 확인</summary>

```
"Spring Boot로 이미지 업로드 API를 구현해줘.

[환경]
- Spring Boot 3.2, Java 17
- 저장 위치: 로컬 파일 시스템 (/uploads/images/)
- 프론트엔드: Vue 3 (Multipart form-data)

[API 명세]
엔드포인트: POST /api/upload/image
요청: multipart/form-data
- file: 이미지 파일

성공 응답 (200):
{
  "url": "/uploads/images/550e8400-e29b-41d4-a716-446655440000.jpg",
  "filename": "original-name.jpg",
  "size": 524288,
  "uploadedAt": "2025-10-16T10:30:00"
}

실패 응답 (400):
{
  "error": "INVALID_FILE_TYPE",
  "message": "jpg, png, gif 파일만 업로드 가능합니다."
}

[요구사항]
1. 허용 확장자: jpg, jpeg, png, gif
2. 최대 파일 크기: 5MB
3. 파일명: UUID로 생성 (중복 방지)
4. 원본 파일명도 DB에 저장
5. 업로드 실패 시 적절한 에러 메시지

[보안]
- 파일 확장자 검증 (MIME type + 확장자)
- 파일 크기 제한
- 악성 파일 방지 (허용 목록 방식)

[구현 방식]
- FileUploadService로 비즈니스 로직 분리
- UploadFile 엔티티로 업로드 이력 관리
- 실제 파일 저장 로직 설명
- application.yml에 업로드 설정 추가

에러 처리와 보안 고려사항을 포함해서 구현해줘."
```
</details>

---

### 연습 3: 데이터베이스 스키마 설계

**모호한 요청:**
```
"블로그 데이터베이스 만들어줘"
```

**당신의 프롬프트 작성:**
```
[여기에 작성해보세요]
















```

**모범 답안:**
<details>
<summary>클릭하여 확인</summary>

```
"블로그 시스템을 위한 MySQL 데이터베이스 스키마를 설계해줘.

[기능 요구사항]
1. 사용자 관리: 회원가입, 로그인, 프로필
2. 게시글: CRUD, 카테고리, 태그
3. 댓글: 계층형 댓글 (대댓글)
4. 좋아요: 게시글/댓글 좋아요
5. 이미지: 게시글 이미지 첨부

[테이블 목록]
- users: 사용자
- posts: 게시글
- categories: 카테고리
- tags: 태그
- post_tags: 게시글-태그 (N:M)
- comments: 댓글
- likes: 좋아요
- images: 이미지

[각 테이블별 설계 요청]
1. 컬럼 목록 (이름, 타입, NULL 여부, 기본값)
2. Primary Key, Foreign Key
3. 인덱스 설계 (성능 최적화)
4. 제약 조건 (UNIQUE, CHECK 등)

[추가 요구사항]
- created_at, updated_at, deleted_at (soft delete)
- 각 테이블의 관계 설명 (1:1, 1:N, N:M)
- ERD 다이어그램 (텍스트로 표현)
- 정규화 수준 설명 (왜 이렇게 나눴는지)

[성능 고려]
- 자주 조회되는 컬럼에 인덱스
- 검색 성능을 위한 Full-text index
- 페이징 쿼리 최적화를 위한 설계

각 테이블의 용도와 관계를 자세히 설명해주고,
JPA Entity 클래스로도 변환해줘."
```
</details>

---

## 🎨 상황별 프롬프트 템플릿

### 템플릿 1: 새 기능 구현

```
"[기능명]을 구현해줘.

[환경]
- 기술 스택: [Spring Boot 버전, Java 버전, 기타]
- 연동: [프론트엔드, 외부 API 등]

[API 명세]
엔드포인트: [HTTP 메서드] [경로]
요청: [바디/파라미터 구조]
응답: [성공/실패 응답 예시]

[요구사항]
1. [핵심 요구사항 1]
2. [핵심 요구사항 2]
3. [예외 처리 방식]

[구현 방식]
- [아키텍처 패턴]
- [사용할 라이브러리]
- [특별히 고려할 점]

[추가]
- 주석으로 설명
- [테스트 코드 필요 여부]
- [보안/성능 고려사항]"
```

### 템플릿 2: 코드 리뷰 요청

```
"다음 코드를 리뷰해줘.

[코드]
```java
[코드 붙여넣기]
```

[리뷰 포인트]
1. [성능]
   - N+1 문제 있는지
   - 쿼리 최적화 가능한지
   
2. [보안]
   - SQL Injection 취약점
   - 입력값 검증 누락
   
3. [코드 품질]
   - 가독성
   - 중복 코드
   - 네이밍
   
4. [아키텍처]
   - 계층 분리 적절한지
   - 책임 분리 (SRP)

[개선 방안]
- 구체적인 수정 코드 제시
- 왜 그렇게 바꿔야 하는지 설명
- Best Practice 제안"
```

### 템플릿 3: 에러 해결

```
"다음 에러를 해결하고 싶어.

[에러 메시지]
```
[전체 스택 트레이스]
```

[발생 상황]
- [어떤 작업을 할 때]
- [어떤 API 호출 시]
- [재현 방법]

[현재 코드]
```java
[관련 코드]
```

[시도한 해결 방법]
1. [시도 1] - [결과]
2. [시도 2] - [결과]

[질문]
1. 이 에러의 원인은 무엇인가?
2. 어떻게 해결할 수 있는가?
3. 재발 방지 방법은?
4. 비슷한 상황을 예방하려면?"
```

### 템플릿 4: 리팩토링

```
"다음 코드를 리팩토링해줘.

[현재 코드]
```java
[리팩토링할 코드]
```

[문제점]
- [코드가 너무 길다]
- [중복이 많다]
- [가독성이 떨어진다]
- [테스트하기 어렵다]

[리팩토링 목표]
1. [단일 책임 원칙 적용]
2. [중복 제거]
3. [명확한 네이밍]
4. [테스트 용이성]

[요청]
- 리팩토링 전후 비교
- 각 변경의 이유 설명
- 추가 개선 가능한 점
- 디자인 패턴 적용 제안"
```

---

## 💡 프롬프트 작성 체크리스트

프롬프트를 작성할 때마다 다음을 확인하세요:

### 필수 요소
- [ ] **목적**: 무엇을 만들거나 해결하려는가?
- [ ] **환경**: 기술 스택, 버전, 제약사항
- [ ] **명세**: API, 데이터 구조, 입출력 형식
- [ ] **요구사항**: 반드시 포함되어야 할 기능

### 선택 요소 (상황에 따라)
- [ ] **예시**: 원하는 결과물의 샘플
- [ ] **제약사항**: 보안, 성능, 비즈니스 룰
- [ ] **구현 방식**: 선호하는 아키텍처, 패턴
- [ ] **설명 요청**: 주석, 문서화, 학습용 설명

### 추가 요청
- [ ] **에러 처리**: 예외 상황 대응
- [ ] **테스트**: 단위 테스트, 통합 테스트
- [ ] **최적화**: 성능, 쿼리 튜닝
- [ ] **보안**: 취약점 점검, 검증 로직

---

## 🚀 레벨업 팁

### Tip 1: 점진적으로 구체화하기

**1단계:**
```
"Spring Boot 프로젝트 만들어줘"
```

**2단계:**
```
"Spring Boot 3.2로 REST API 프로젝트 만들어줘.
JPA, MySQL, Security 포함."
```

**3단계:**
```
"Spring Boot 3.2로 블로그 백엔드를 만들어줘.
- 게시글, 사용자, 댓글 기능
- JWT 인증
- MySQL + JPA
- Docker Compose 개발 환경"
```

### Tip 2: 예시 활용하기

코드나 데이터 구조의 예시를 제공하면 훨씬 정확한 결과를 얻습니다.

```
"다음과 같은 응답 형식의 API를 만들어줘:

{
  "status": "success",
  "data": {
    ...
  },
  "meta": {
    "timestamp": "2025-10-16T10:30:00Z"
  }
}"
```

### Tip 3: 반복하며 개선하기

첫 시도에서 완벽할 필요 없습니다. 결과를 보고 개선 요청하세요.

```
1차: "게시글 API 만들어줘"
2차: "검색 기능 추가해줘"
3차: "페이징 성능 최적화해줘"
4차: "캐싱 전략 추가해줘"
```

---

## 📚 다음 단계

1. **실습**: 위의 연습 문제를 직접 풀어보기
2. **적용**: 실제 프로젝트에서 프롬프트 작성해보기
3. **피드백**: AI의 응답 품질을 보고 프롬프트 개선하기

---

**💡 핵심**: 좋은 프롬프트 = 명확한 요구사항 + 충분한 컨텍스트 + 구체적인 예시

