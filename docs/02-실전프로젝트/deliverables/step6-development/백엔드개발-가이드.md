# 백엔드 개발 가이드

**프로젝트명:** SimpleBlog
**작성일:** 2025-10-17
**작성자:** 개발팀
**버전:** 1.0

---

## 📌 이 단계의 목적

### 왜 백엔드 개발 가이드를 작성하나요?

**"실제로 어떻게 코딩하는가?"**

PM은 코드를 직접 작성하지 않지만, **개발 과정을 이해**해야 다음을 할 수 있습니다:
- 개발 일정 산정 (API 1개당 2시간)
- 개발자와 기술 회의
- 고객에게 진행 상황 설명

### PM이 꼭 알아야 할 것

#### 1. 3계층 아키텍처 (가장 중요!)

```
사용자 → Controller → Service → Repository → Database
         (접수)     (처리)     (저장)

실무 비유:
Controller = 고객센터 직원 (전화 받고, 담당자에게 연결)
Service    = 실무 담당자 (업무 처리, 비즈니스 로직)
Repository = 창고 담당자 (DB에서 데이터 가져오기/저장)
```

**왜 3계층으로 나누나요?**
```
❌ 나쁜 예: Controller에서 DB 직접 접근
→ 나중에 DB 변경하면 모든 코드 수정

✅ 좋은 예: 3계층 분리
→ DB만 바꾸면 Repository만 수정
```

---

#### 2. 개발 순서 (중요!)

```
1. Entity 작성 (DB 테이블 ↔ Java 클래스)
2. Repository 작성 (DB 접근 인터페이스)
3. DTO 작성 (요청/응답 데이터 구조)
4. Service 작성 (비즈니스 로직)
5. Controller 작성 (API 엔드포인트)
6. 테스트 작성 (정상 동작 확인)
```

**왜 이 순서인가요?**
```
아래부터 위로 (Bottom-Up):
Database → Entity → Repository → Service → Controller

마치 건물 짓듯이:
1층(DB) → 2층(Repository) → 3층(Service) → 옥상(Controller)
```

---

#### 3. 실무 Tip

⭐ **코드 리뷰 필수**
```
개발자 혼자 코딩 → PR (Pull Request) → 팀원 리뷰 → 병합

코드 리뷰에서 확인할 것:
- 3계층 아키텍처 준수했는지
- 예외 처리 했는지
- 테스트 작성했는지
- 코드 중복 없는지
```

⭐ **작은 단위로 commit**
```
❌ 나쁜 예: "기능 완성" (1,000줄 변경)
✅ 좋은 예: "feat: Post Entity 작성" (50줄 변경)

작게 쪼개야 나중에 문제 생겼을 때 롤백 쉬움
```

⭐ **주석은 "왜"를 설명**
```
❌ 나쁜 예:
// 게시글 목록 조회
public List<Post> findAll() { ... }
→ 코드 보면 알 수 있음

✅ 좋은 예:
// 최신순 정렬을 위해 created_at DESC 인덱스 활용
public List<Post> findAllOrderByCreatedAtDesc() { ... }
→ "왜 이렇게 했는지" 설명
```

---

#### 4. 제안서/PT에서 설명하는 법

**아키텍처 설명 예시:**

> "SimpleBlog는 **3계층 아키텍처**를 적용했습니다.
>
> **Controller 계층 (API):**
> - REST API 엔드포인트 5개
> - JSON 요청/응답 처리
> - 입력값 유효성 검증
>
> **Service 계층 (비즈니스 로직):**
> - 게시글 CRUD 로직
> - 트랜잭션 관리
> - 예외 처리
>
> **Repository 계층 (데이터 접근):**
> - Spring Data JPA 사용
> - SQL 자동 생성 (80% 이상)
> - 복잡한 쿼리는 JPQL 직접 작성
>
> **장점:**
> - 계층별 독립적 테스트 가능
> - 유지보수 용이 (변경 영향도 최소화)
> - 표준 아키텍처로 개발자 이해 쉬움"

---

#### 5. 공무원이 자주 하는 질문

**Q1: "코드 몇 줄이나 되나요?"**
A: "SimpleBlog 기준 약 500~700줄입니다.

   - Entity: 50줄
   - Repository: 20줄 (인터페이스만)
   - Service: 150줄
   - Controller: 100줄
   - DTO: 80줄
   - 테스트: 200줄

   참고로 RealWorld 같은 중형 프로젝트는 5,000줄 정도입니다."

**Q2: "개발 기간은 얼마나 걸리나요?"**
A: "SimpleBlog 기준 백엔드 개발자 1명 기준:

   - 환경 설정: 0.5일
   - Entity + Repository: 0.5일
   - Service 개발: 1일
   - Controller 개발: 1일
   - 테스트 작성: 1일
   - 버그 수정: 0.5일
   **총: 4.5일 (약 1주일)**

   여유를 두고 2주 산정 권장합니다."

**Q3: "Java는 코드가 많다고 들었는데?"**
A: "예전 Java는 그랬지만, 최신 Java + Lombok은 간결합니다.

   **예전 Java (100줄):**
   ```java
   public class Post {
       private Long id;
       public Long getId() { return id; }
       public void setId(Long id) { this.id = id; }
       // ... 반복
   }
   ```

   **현대 Java + Lombok (10줄):**
   ```java
   @Data
   @Entity
   public class Post {
       @Id @GeneratedValue
       private Long id;
       private String title;
   }
   ```

   → 10배 간결!"

**Q4: "에러가 나면 어떻게 하나요?"**
A: "다층 방어 구조를 만듭니다:

   1차: 입력값 검증 (Controller)
   2차: 비즈니스 로직 검증 (Service)
   3차: 예외 처리 (GlobalExceptionHandler)

   고객에게는 친절한 에러 메시지:
   ```json
   {
     \"error\": \"POST_NOT_FOUND\",
     \"message\": \"게시글을 찾을 수 없습니다. (ID: 999)\"
   }
   ```"

---

## 1. 개발 순서 (실습 따라하기)

### 1.1 Entity 작성 (DB 테이블 ↔ Java 클래스)

**파일 위치:** `src/main/java/com/simpleblog/entity/Post.java`

```java
package com.simpleblog.entity;

import jakarta.persistence.*;
import lombok.AccessLevel;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Entity
@Table(name = "posts")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@EntityListeners(AuditingEntityListener.class)
public class Post {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 200)
    private String title;

    @Column(nullable = false, columnDefinition = "TEXT")
    private String content;

    @Column(nullable = false, length = 100)
    private String author;

    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(nullable = false)
    private LocalDateTime updatedAt;

    @Builder
    public Post(String title, String content, String author) {
        this.title = title;
        this.content = content;
        this.author = author;
    }

    // 비즈니스 메서드
    public void update(String title, String content) {
        this.title = title;
        this.content = content;
    }
}
```

**PM이 알아야 할 어노테이션:**
```
@Entity         → JPA Entity (DB 테이블과 매핑)
@Table          → 테이블 이름 지정
@Id             → 기본키 (Primary Key)
@GeneratedValue → 자동 증가 (AUTO_INCREMENT)
@Column         → 컬럼 설정 (null 허용, 길이 등)
@CreatedDate    → 생성일시 자동 설정
@LastModifiedDate → 수정일시 자동 업데이트
```

---

### 1.2 Repository 작성 (DB 접근)

**파일 위치:** `src/main/java/com/simpleblog/repository/PostRepository.java`

```java
package com.simpleblog.repository;

import com.simpleblog.entity.Post;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface PostRepository extends JpaRepository<Post, Long> {

    // 기본 CRUD는 JpaRepository가 제공:
    // - save(Post) → INSERT or UPDATE
    // - findById(Long) → SELECT * FROM posts WHERE id = ?
    // - findAll() → SELECT * FROM posts
    // - deleteById(Long) → DELETE FROM posts WHERE id = ?

    // 커스텀 쿼리: 최신순 정렬
    List<Post> findAllByOrderByCreatedAtDesc();

    // 제목으로 검색 (LIKE 검색) - 2차 개발
    // List<Post> findByTitleContaining(String keyword);
}
```

**PM이 알아야 할 Spring Data JPA 마법:**
```
JpaRepository를 extends 하면:
→ 기본 CRUD 메서드 20개 자동 제공!
→ SQL 작성 안 해도 됨

메서드 이름만으로 쿼리 자동 생성:
findAllByOrderByCreatedAtDesc()
→ SELECT * FROM posts ORDER BY created_at DESC

findByTitleContaining("Java")
→ SELECT * FROM posts WHERE title LIKE '%Java%'
```

---

### 1.3 DTO 작성 (요청/응답 객체)

**왜 DTO가 필요한가?**
```
❌ Entity를 직접 반환하면:
- 비밀번호 같은 민감 정보 노출 위험
- 순환 참조 문제 (연관 관계 있을 때)
- API 스펙 변경 시 DB 스키마도 변경

✅ DTO 사용:
- 필요한 필드만 선택적으로 전송
- API 스펙과 DB 스키마 독립
```

**파일 위치:** `src/main/java/com/simpleblog/dto/`

**PostCreateRequest.java (게시글 생성 요청):**
```java
package com.simpleblog.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Getter
@NoArgsConstructor
public class PostCreateRequest {

    @NotBlank(message = "제목은 필수 입력 항목입니다.")
    @Size(max = 200, message = "제목은 최대 200자까지 입력 가능합니다.")
    private String title;

    @NotBlank(message = "내용은 필수 입력 항목입니다.")
    private String content;

    @NotBlank(message = "작성자는 필수 입력 항목입니다.")
    @Size(max = 100, message = "작성자는 최대 100자까지 입력 가능합니다.")
    private String author;
}
```

**PostUpdateRequest.java (게시글 수정 요청):**
```java
package com.simpleblog.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Getter
@NoArgsConstructor
public class PostUpdateRequest {

    @NotBlank(message = "제목은 필수 입력 항목입니다.")
    @Size(max = 200, message = "제목은 최대 200자까지 입력 가능합니다.")
    private String title;

    @NotBlank(message = "내용은 필수 입력 항목입니다.")
    private String content;
}
```

**PostResponse.java (게시글 응답):**
```java
package com.simpleblog.dto;

import com.simpleblog.entity.Post;
import lombok.Builder;
import lombok.Getter;

import java.time.LocalDateTime;

@Getter
@Builder
public class PostResponse {

    private Long id;
    private String title;
    private String content;
    private String author;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    // Entity → DTO 변환
    public static PostResponse from(Post post) {
        return PostResponse.builder()
                .id(post.getId())
                .title(post.getTitle())
                .content(post.getContent())
                .author(post.getAuthor())
                .createdAt(post.getCreatedAt())
                .updatedAt(post.getUpdatedAt())
                .build();
    }
}
```

**PostListResponse.java (목록 조회 응답):**
```java
package com.simpleblog.dto;

import com.simpleblog.entity.Post;
import lombok.Builder;
import lombok.Getter;

import java.time.LocalDateTime;

@Getter
@Builder
public class PostListResponse {

    private Long id;
    private String title;
    private String author;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    // 목록은 content 제외 (성능 최적화)
    public static PostListResponse from(Post post) {
        return PostListResponse.builder()
                .id(post.getId())
                .title(post.getTitle())
                .author(post.getAuthor())
                .createdAt(post.getCreatedAt())
                .updatedAt(post.getUpdatedAt())
                .build();
    }
}
```

---

### 1.4 Service 작성 (비즈니스 로직)

**파일 위치:** `src/main/java/com/simpleblog/service/PostService.java`

```java
package com.simpleblog.service;

import com.simpleblog.dto.PostCreateRequest;
import com.simpleblog.dto.PostListResponse;
import com.simpleblog.dto.PostResponse;
import com.simpleblog.dto.PostUpdateRequest;
import com.simpleblog.entity.Post;
import com.simpleblog.repository.PostRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class PostService {

    private final PostRepository postRepository;

    /**
     * 게시글 목록 조회 (최신순)
     */
    public List<PostListResponse> getAllPosts() {
        return postRepository.findAllByOrderByCreatedAtDesc()
                .stream()
                .map(PostListResponse::from)
                .collect(Collectors.toList());
    }

    /**
     * 게시글 상세 조회
     */
    public PostResponse getPost(Long id) {
        Post post = postRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException(
                        "게시글을 찾을 수 없습니다. (ID: " + id + ")"
                ));
        return PostResponse.from(post);
    }

    /**
     * 게시글 생성
     */
    @Transactional
    public PostResponse createPost(PostCreateRequest request) {
        Post post = Post.builder()
                .title(request.getTitle())
                .content(request.getContent())
                .author(request.getAuthor())
                .build();

        Post savedPost = postRepository.save(post);
        return PostResponse.from(savedPost);
    }

    /**
     * 게시글 수정
     */
    @Transactional
    public PostResponse updatePost(Long id, PostUpdateRequest request) {
        Post post = postRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException(
                        "게시글을 찾을 수 없습니다. (ID: " + id + ")"
                ));

        post.update(request.getTitle(), request.getContent());
        // @Transactional에 의해 자동으로 UPDATE 쿼리 실행 (Dirty Checking)

        return PostResponse.from(post);
    }

    /**
     * 게시글 삭제
     */
    @Transactional
    public void deletePost(Long id) {
        if (!postRepository.existsById(id)) {
            throw new IllegalArgumentException(
                    "게시글을 찾을 수 없습니다. (ID: " + id + ")"
            );
        }
        postRepository.deleteById(id);
    }
}
```

**PM이 알아야 할 Service 계층 포인트:**
```
@Transactional:
- 메서드 실행 중 오류 발생 시 자동 롤백
- 여러 DB 작업을 하나의 트랜잭션으로 묶음

@Transactional(readOnly = true):
- 클래스 레벨: 기본은 읽기 전용
- 메서드 레벨: 쓰기가 필요한 곳만 @Transactional

Dirty Checking (변경 감지):
- post.update() 호출하면
- @Transactional이 자동으로 UPDATE 쿼리 실행
- 별도로 save() 안 해도 됨!
```

---

### 1.5 Controller 작성 (REST API)

**파일 위치:** `src/main/java/com/simpleblog/controller/PostController.java`

```java
package com.simpleblog.controller;

import com.simpleblog.dto.PostCreateRequest;
import com.simpleblog.dto.PostListResponse;
import com.simpleblog.dto.PostResponse;
import com.simpleblog.dto.PostUpdateRequest;
import com.simpleblog.service.PostService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/posts")
@RequiredArgsConstructor
public class PostController {

    private final PostService postService;

    /**
     * 게시글 목록 조회
     * GET /api/posts
     */
    @GetMapping
    public ResponseEntity<List<PostListResponse>> getAllPosts() {
        List<PostListResponse> posts = postService.getAllPosts();
        return ResponseEntity.ok(posts);
    }

    /**
     * 게시글 상세 조회
     * GET /api/posts/{id}
     */
    @GetMapping("/{id}")
    public ResponseEntity<PostResponse> getPost(@PathVariable Long id) {
        PostResponse post = postService.getPost(id);
        return ResponseEntity.ok(post);
    }

    /**
     * 게시글 생성
     * POST /api/posts
     */
    @PostMapping
    public ResponseEntity<PostResponse> createPost(
            @Valid @RequestBody PostCreateRequest request
    ) {
        PostResponse post = postService.createPost(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(post);
    }

    /**
     * 게시글 수정
     * PUT /api/posts/{id}
     */
    @PutMapping("/{id}")
    public ResponseEntity<PostResponse> updatePost(
            @PathVariable Long id,
            @Valid @RequestBody PostUpdateRequest request
    ) {
        PostResponse post = postService.updatePost(id, request);
        return ResponseEntity.ok(post);
    }

    /**
     * 게시글 삭제
     * DELETE /api/posts/{id}
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletePost(@PathVariable Long id) {
        postService.deletePost(id);
        return ResponseEntity.noContent().build();
    }
}
```

**PM이 알아야 할 Controller 어노테이션:**
```
@RestController     → REST API 컨트롤러
@RequestMapping     → 기본 URL (/api/posts)
@GetMapping         → GET 요청 (조회)
@PostMapping        → POST 요청 (생성)
@PutMapping         → PUT 요청 (수정)
@DeleteMapping      → DELETE 요청 (삭제)
@PathVariable       → URL 경로에서 값 추출 (/api/posts/1 → id=1)
@RequestBody        → JSON 요청 body를 DTO로 변환
@Valid              → 유효성 검증 실행 (@NotBlank 등)
```

---

### 1.6 예외 처리 (GlobalExceptionHandler)

**파일 위치:** `src/main/java/com/simpleblog/exception/GlobalExceptionHandler.java`

```java
package com.simpleblog.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    /**
     * 유효성 검증 실패 (400 Bad Request)
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(
            MethodArgumentNotValidException ex
    ) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });

        ErrorResponse response = ErrorResponse.builder()
                .error("VALIDATION_ERROR")
                .message("입력값 검증에 실패했습니다.")
                .details(errors)
                .timestamp(LocalDateTime.now())
                .build();

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
    }

    /**
     * 리소스 없음 (404 Not Found)
     */
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponse> handleNotFoundException(
            IllegalArgumentException ex
    ) {
        ErrorResponse response = ErrorResponse.builder()
                .error("RESOURCE_NOT_FOUND")
                .message(ex.getMessage())
                .timestamp(LocalDateTime.now())
                .build();

        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
    }

    /**
     * 서버 내부 오류 (500 Internal Server Error)
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception ex) {
        ErrorResponse response = ErrorResponse.builder()
                .error("INTERNAL_SERVER_ERROR")
                .message("서버 내부 오류가 발생했습니다.")
                .timestamp(LocalDateTime.now())
                .build();

        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
    }
}
```

**ErrorResponse.java:**
```java
package com.simpleblog.exception;

import lombok.Builder;
import lombok.Getter;

import java.time.LocalDateTime;
import java.util.Map;

@Getter
@Builder
public class ErrorResponse {
    private String error;
    private String message;
    private Map<String, String> details;
    private LocalDateTime timestamp;
}
```

---

## 2. 실행 및 테스트

### 2.1 Application 실행

**SimpleblogApplication.java에 JPA Auditing 활성화 추가:**
```java
package com.simpleblog;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@SpringBootApplication
@EnableJpaAuditing  // @CreatedDate, @LastModifiedDate 활성화
public class SimpleblogApplication {

    public static void main(String[] args) {
        SpringApplication.run(SimpleblogApplication.class, args);
    }

}
```

### 2.2 Postman 테스트

**1) 게시글 목록 조회:**
```
GET http://localhost:8080/api/posts
```

**2) 게시글 생성:**
```
POST http://localhost:8080/api/posts
Content-Type: application/json

{
  "title": "Postman 테스트",
  "content": "Postman으로 작성한 게시글입니다.",
  "author": "테스터"
}
```

**3) 게시글 상세 조회:**
```
GET http://localhost:8080/api/posts/1
```

**4) 게시글 수정:**
```
PUT http://localhost:8080/api/posts/1
Content-Type: application/json

{
  "title": "수정된 제목",
  "content": "수정된 내용입니다."
}
```

**5) 게시글 삭제:**
```
DELETE http://localhost:8080/api/posts/1
```

---

## 3. 변경 이력

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|----------|
| 1.0 | 2025-10-17 | 개발팀 | 최초 작성 |

---

**다음 단계:** [7단계 테스트](../step7-testing/) 🚀
